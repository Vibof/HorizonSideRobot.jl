<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Начальные сведения о языке программирования Julia · HorizonSideRobots.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Vibof.github.io/HorizonSideRobots.jl/language/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HorizonSideRobots.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Заглавная</a></li><li><a class="tocitem" href="../setup/">Как установить Робота на своем компьютере</a></li><li><a class="tocitem" href="../constructor/">Конструктор объектов типа Robot</a></li><li><a class="tocitem" href="../api/">Командный интерфейс Робота</a></li><li><a class="tocitem" href="../example/">Пример выполнения программы для Робота</a></li><li class="is-active"><a class="tocitem" href>Начальные сведения о языке программирования Julia</a><ul class="internal"><li><a class="tocitem" href="#ОГЛАВЛЕНИЕ"><span>ОГЛАВЛЕНИЕ</span></a></li><li><a class="tocitem" href="#Функции"><span>Функции</span></a></li><li><a class="tocitem" href="#Циклы"><span>Циклы</span></a></li><li><a class="tocitem" href="#Ветвления"><span>Ветвления</span></a></li><li><a class="tocitem" href="#Переменные,-типы,-выражения"><span>Переменные, типы, выражения</span></a></li><li><a class="tocitem" href="#Итерируемые-объекты"><span>Итерируемые объекты</span></a></li><li><a class="tocitem" href="#Система-встроенных-и-пользовательских-типов"><span>Система встроенных и пользовательских типов</span></a></li><li><a class="tocitem" href="#Вывод-на-экран"><span>Вывод на экран</span></a></li><li><a class="tocitem" href="#Работа-в-REPL"><span>Работа в REPL</span></a></li><li><a class="tocitem" href="#Немного-о-терминологии"><span>Немного о терминологии</span></a></li><li><a class="tocitem" href="#Интроспекция"><span>Интроспекция</span></a></li><li><a class="tocitem" href="#Дополнительные-источники-информации-о-языке-Julia"><span>Дополнительные источники информации о языке Julia</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Начальные сведения о языке программирования Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Начальные сведения о языке программирования Julia</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Vibof/HorizonSideRobots.jl/blob/master/docs/src/language.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="НАЧАЛЬНЫЕ-СВЕДЕНИЯ-О-ЯЗЫКЕ-ПРОГРАММИРОВАНИЯ-JULIA"><a class="docs-heading-anchor" href="#НАЧАЛЬНЫЕ-СВЕДЕНИЯ-О-ЯЗЫКЕ-ПРОГРАММИРОВАНИЯ-JULIA">НАЧАЛЬНЫЕ СВЕДЕНИЯ О ЯЗЫКЕ ПРОГРАММИРОВАНИЯ JULIA</a><a id="НАЧАЛЬНЫЕ-СВЕДЕНИЯ-О-ЯЗЫКЕ-ПРОГРАММИРОВАНИЯ-JULIA-1"></a><a class="docs-heading-anchor-permalink" href="#НАЧАЛЬНЫЕ-СВЕДЕНИЯ-О-ЯЗЫКЕ-ПРОГРАММИРОВАНИЯ-JULIA" title="Permalink"></a></h1><p>Если вы знакомы с языком Python, то очень многое в языке Julia вам покажется знакомым. Но есть и существенные различия. </p><p>Например, в языке Julia отступы не имеют принципиального значения, такое как они имеют в языке Python, где отступы определяют структуру кода. И не надо ставить двоеточия в конце заголовков функций, циклов и т.д., как в Python. Вместо всего этого используется ключевое слово <code>end</code>, ограничивающее тело той или иной конструкции языка (см. ниже).</p><p>Но тем не менее язык Julia во многом похож Python (но это только внешнее сходство). Благодаря этому сходству, например, часто удаётся выяснить имя и описание какой-либо вдруг понадобившейся стандартной функции Julia (если по каким-то причинам это не удалось сделать напрямую): велика вероятность того, что нужная функция называется и действует так же, как и в Python. При этом на сегодняшнй день информацию по языку Python на русском языке найти значительно проще.</p><hr/><h2 id="ОГЛАВЛЕНИЕ"><a class="docs-heading-anchor" href="#ОГЛАВЛЕНИЕ">ОГЛАВЛЕНИЕ</a><a id="ОГЛАВЛЕНИЕ-1"></a><a class="docs-heading-anchor-permalink" href="#ОГЛАВЛЕНИЕ" title="Permalink"></a></h2><ul><li><a href="#НАЧАЛЬНЫЕ-СВЕДЕНИЯ-О-ЯЗЫКЕ-ПРОГРАММИРОВАНИЯ-JULIA">НАЧАЛЬНЫЕ СВЕДЕНИЯ О ЯЗЫКЕ ПРОГРАММИРОВАНИЯ JULIA</a><ul><li><a href="#Функции">Функции</a><ul><li><a href="#**Способы-определения-функций**"><strong>Способы определения функций</strong></a></li><li><a href="#**Позиционные-параметры-функций**"><strong>Позиционные параметры функций</strong></a></li><li><a href="#**Формальные-и-фактические-параметры-функций**"><strong>Формальные и фактические параметры функций</strong></a></li><li><a href="#**Позиционные-и-именованные-параметры**"><strong>Позиционные и именованные параметры</strong></a></li><li><a href="#**Возвращаемые-функцией-значения**"><strong>Возвращаемые функцией значения</strong></a></li><li><a href="#**Множественная-диспетчеризация**"><strong>Множественная диспетчеризация</strong></a></li></ul></li><li><a href="#Циклы">Циклы</a><ul><li><a href="#**&quot;Арифметический&quot;-цикл**"><strong>&quot;Арифметический&quot; цикл</strong></a></li><li><a href="#**Цикл-с-предусловием**"><strong>Цикл с предусловием</strong></a></li><li><a href="#**Значение,-возвращаемое-оператором-цикла**"><strong>Значение, возвращаемое оператором цикла</strong></a></li><li><a href="#**Операторы-изменения-поряка-выполнения-цикла**"><strong>Операторы изменения поряка выполнения цикла</strong></a></li><li><a href="#**Вложенные-циклы**"><strong>Вложенные циклы</strong></a></li></ul></li><li><a href="#Ветвления">Ветвления</a><ul><li><a href="#**Значение,-возвращаемое-оператором-ветвления**"><strong>Значение, возвращаемое оператором ветвления</strong></a></li></ul></li><li><a href="#Переменные,-типы,-выражения">Переменные, типы, выражения</a></li><li><a href="#Итерируемые-объекты">Итерируемые объекты</a><ul><li><a href="#**Массивы**"><strong>Массивы</strong></a></li><li><a href="#**Диапазоны**"><strong>Диапазоны</strong></a></li><li><a href="#**&quot;Списковые-включения&quot;**"><strong>&quot;Списковые включения&quot;</strong></a></li><li><a href="#**Генераторы**"><strong>Генераторы</strong></a></li><li><a href="#**Кортежи**"><strong>Кортежи</strong></a></li><li><a href="#**Строки**"><strong>Строки</strong></a></li><li><a href="#**Множества-и-словари**"><strong>Множества и словари</strong></a></li><li><a href="#**Функция-collect**"><strong>Функция collect</strong></a></li><li><a href="#**Операция-&quot;распаковки&quot;-массива**"><strong>Операция &quot;распаковки&quot; массива</strong></a></li></ul></li><li><a href="#Система-встроенных-и-пользовательских-типов">Система встроенных и пользовательских типов</a></li><li><a href="#Вывод-на-экран">Вывод на экран</a></li><li><a href="#Работа-в-REPL">Работа в REPL</a></li><li><a href="#Немного-о-терминологии">Немного о терминологии</a></li><li><a href="#Интроспекция">Интроспекция</a></li><li><a href="#Дополнительные-источники-информации-о-языке-Julia">Дополнительные источники информации о языке Julia</a></li></ul></li></ul><hr/><h2 id="Функции"><a class="docs-heading-anchor" href="#Функции">Функции</a><a id="Функции-1"></a><a class="docs-heading-anchor-permalink" href="#Функции" title="Permalink"></a></h2><p>Функции - это основные &quot;кирпичики&quot; из которых состоят программы. </p><p>Сама программа, обычно, тоже является функцией, которую называют главной функцией.</p><h3 id="**Способы-определения-функций**"><a class="docs-heading-anchor" href="#**Способы-определения-функций**"><strong>Способы определения функций</strong></a><a id="**Способы-определения-функций**-1"></a><a class="docs-heading-anchor-permalink" href="#**Способы-определения-функций**" title="Permalink"></a></h3><p>Например, определение некоторой функции с одним агрументом (параметром) может выглядеть так</p><pre><code class="language-julia hljs">function f(x)
    return x^2
end</code></pre><p>или так</p><pre><code class="language-julia hljs">function f(x)
    x^2 # функция всегда возвращает значение последнего оператора в своем теле
end</code></pre><p>или даже так</p><pre><code class="language-julia hljs">f(x)=x^2</code></pre><p>Последний способ обычно используют для совсем коротких определений.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Позиционные-параметры-функций**"><a class="docs-heading-anchor" href="#**Позиционные-параметры-функций**"><strong>Позиционные параметры функций</strong></a><a id="**Позиционные-параметры-функций**-1"></a><a class="docs-heading-anchor-permalink" href="#**Позиционные-параметры-функций**" title="Permalink"></a></h3><p>Количество аргументов у функций может быть любым, в том числе параметров может не быть совсем.</p><p>Вот пример функции без параметров</p><pre><code class="language-julia hljs">one()=1</code></pre><p>А вот пример функции с двумя параметрами</p><pre><code class="language-julia hljs">expr(x,y)=sin(x)+cos(y)</code></pre><p>В приведенном примере параметры функции называются <strong>позиционными</strong>. Смысл этого названия разъясняется в следующем подразделе.</p><hr/><p><a href="#начальные-сведения-о-языке-программирования-julia">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Формальные-и-фактические-параметры-функций**"><a class="docs-heading-anchor" href="#**Формальные-и-фактические-параметры-функций**"><strong>Формальные и фактические параметры функций</strong></a><a id="**Формальные-и-фактические-параметры-функций**-1"></a><a class="docs-heading-anchor-permalink" href="#**Формальные-и-фактические-параметры-функций**" title="Permalink"></a></h3><p>Параметры, которые фигурируют в <strong>определениях</strong> функций принято называть <strong>формальными</strong>. По сути формальные параметры представляют собой просто символы, которые требуются, чтобы записать алгоритм вычисления функции. Имя любого формального параметра может быть заменено на другое, и от этого опредление функции не изменится.</p><p>А вот при вызове функции на исполнение, на место формальных параметров должны быть подставлены <strong>фактические</strong> параметры, которые должны представлять некоторые конкретные значения.</p><p>В рассмотренных примерах все аргументы функций являлись так называемыми <strong>позиционными параметрами</strong>. Это название происходит от того, что соответствие между формальными и фактическими параметрами устанавливается благодаря тому, что в списке параметров их позици фиксированы, т.е. каждому параметру определено строго определенное место в списке.</p><hr/><p><a href="#начальные-сведения-о-языке-программирования-julia">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Позиционные-и-именованные-параметры**"><a class="docs-heading-anchor" href="#**Позиционные-и-именованные-параметры**"><strong>Позиционные и именованные параметры</strong></a><a id="**Позиционные-и-именованные-параметры**-1"></a><a class="docs-heading-anchor-permalink" href="#**Позиционные-и-именованные-параметры**" title="Permalink"></a></h3><p>В языке Julia (как и в языке Python) наряду с позиционными параметрами у функций могут быть также и <strong>именованные параметры</strong> или их еще называют <strong>ключевыми (key) параметрами</strong>.  Так называются параметры, за которыми прочно закреплены их имена. Например, известная нам функция <code>Robot</code> имеет именованный параметр <code>animate</code>. При вызове данной функции на исполнение этот параметр используется так</p><pre><code class="language-julia hljs">Robot(animate=true)</code></pre><p>Функция может иметь как позиционные, так и именованные параметры, одновременно.  Такова, например, все таже функция <code>Robot</code>, у которой возможны два позиционных и один именованный параметры</p><pre><code class="language-julia hljs">Robot(10, 15, animate=true)</code></pre><p>В определении функций с обоими типами параметров в списке параметров сначала должны перечисляться все позиционные параметры, а затем, после &quot;;&quot; - все именованные (которых тоже может быть несколько). При вызове же этих функций на исполнение, после позиционных именованные параметры могут располагаться в произвольном порядке (позиционные от именованных - могут разделяться просто &quot;,&quot;, но допустима также и &quot;;&quot;).</p><p>Как именованные, так и позиционные параметры могут иметь <strong>значения по умолчанию</strong>. Например, </p><pre><code class="language-julia hljs">julia&gt; quadratic(x,a=1,b=0,c=0)=a*x^2+b*x+c

julia&gt; quadratic(2)
    4</code></pre><p>(здесь все параметры у функции - позиционные).</p><p>Стоит отметить, что в отношении использования именованных параметров синтаксис языка Julia отличается от синтаксиса Python.</p><hr/><p><a href="#начальные-сведения-о-языке-программирования-julia">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Возвращаемые-функцией-значения**"><a class="docs-heading-anchor" href="#**Возвращаемые-функцией-значения**"><strong>Возвращаемые функцией значения</strong></a><a id="**Возвращаемые-функцией-значения**-1"></a><a class="docs-heading-anchor-permalink" href="#**Возвращаемые-функцией-значения**" title="Permalink"></a></h3><p>Если результатом выполнения функции является некоторое значение, то, как правило, функция должна это значение ВОЗВРАЩАТЬ. Для этого в теле функции может быть использован специальный оператор возврата - <code>return</code>. Этот оператор немедленно завершает выполнение функции и передает управление во вне, в точку ее вызова. В ту же точку возвращается (подставляется) возвращаемое функцией значение.</p><p>Если функция что-либо возвращает, то ее вызов может осуществляться из некоторого выражения, например из правой части оператора присваивания. </p><p>Если функция ничего не возвращает, а просто выполняет какие-то другие действия, то такиая функция, в некоторых языках программирования называется <strong>процедурой</strong>. Но в языке Julia такая терминология не используется. В языке Julia любая функция что-то возвращает, даже если она ничего возвращать не должна. В последнем случае возвращаемое значение будет <code>nothing</code>.</p><p>Выше рассматривались примеры функций, возвращающих ровно одно значение.</p><p>Если требуется, чтобы функция возвращала несколько значений, то эти возвращаемые значения должны составляться в кортеж (подробнее о кортежах см. ниже), например</p><pre><code class="language-julia hljs">fun(x,y)=(x+y, x-y) # (x+y, x-y) - это кортеж из двух значений</code></pre><p>Если при этом используется оператор return, то скобки ставить не обязательно:</p><pre><code class="language-julia hljs">function fun(x,y)
    return x+y, x-y
end</code></pre><p>В любом случае в результате вызова </p><pre><code class="language-julia hljs">a,b=fun(3,2)</code></pre><p>получится <code>a=5</code>, <code>b=1</code>.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Множественная-диспетчеризация**"><a class="docs-heading-anchor" href="#**Множественная-диспетчеризация**"><strong>Множественная диспетчеризация</strong></a><a id="**Множественная-диспетчеризация**-1"></a><a class="docs-heading-anchor-permalink" href="#**Множественная-диспетчеризация**" title="Permalink"></a></h3><p>Важная отличительная особенность языка Julia от языка Python, заключается в том, что в определениях функций типы их аргументов можно анотировать, т.е. указывать, какими они должны быть.</p><p>Например, можно было бы дать еще следующие 2 определения</p><pre><code class="language-julia hljs">function f(x::Int)
    return x^3
end

function f(x::Float64)
    return x^4
end</code></pre><p>В результате мы получим еще два метода (варианта) функции f. Оба пределения функции f одновременно быдут существовать. Какое из них будет использовано - зависит от фактического типа аргумента функции (т.е. с аргументом какого типа будет ее вызов). Это называется <a href="https://techytok.com/lesson-multiple-dispatch/">множественной диспетчеризацией</a>. </p><p>Зачем нужна множественная диспетчеризация, и как ей правильно пользоваться в языке Julia - это предмет отдельного разговора. Но заранее заметим, что эта тема имеет в Julia первостепеное значение. </p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Циклы"><a class="docs-heading-anchor" href="#Циклы">Циклы</a><a id="Циклы-1"></a><a class="docs-heading-anchor-permalink" href="#Циклы" title="Permalink"></a></h2><h3 id="**&quot;Арифметический&quot;-цикл**"><a class="docs-heading-anchor" href="#**&quot;Арифметический&quot;-цикл**"><strong>&quot;Арифметический&quot; цикл</strong></a><a id="**&quot;Арифметический&quot;-цикл**-1"></a><a class="docs-heading-anchor-permalink" href="#**&quot;Арифметический&quot;-цикл**" title="Permalink"></a></h3><pre><code class="language-julia hljs">for a in collection 
    println(a)
end

где collecnion - это может быть диапазон, массив (Array), генератор, строка (String), множество (Set), словать (Dict) - см. ниже. 

Например collection = [10,20,30,40,50] - это массив (в данном случае - вектор-столбец)

for i in eachindex(collection) # перебираются индексы элементов колллеции
    println(i)
end

for (i,a) in enumerate(collection) # перебираются пары индекс-значение элементов колллеции
    println(i,&quot; -&gt; &quot;, a) 
end</code></pre><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Цикл-с-предусловием**"><a class="docs-heading-anchor" href="#**Цикл-с-предусловием**"><strong>Цикл с предусловием</strong></a><a id="**Цикл-с-предусловием**-1"></a><a class="docs-heading-anchor-permalink" href="#**Цикл-с-предусловием**" title="Permalink"></a></h3><pre><code class="language-Julia hljs">
while условие_продолжения_цикла
    ...
end</code></pre><h3 id="**Значение,-возвращаемое-оператором-цикла**"><a class="docs-heading-anchor" href="#**Значение,-возвращаемое-оператором-цикла**"><strong>Значение, возвращаемое оператором цикла</strong></a><a id="**Значение,-возвращаемое-оператором-цикла**-1"></a><a class="docs-heading-anchor-permalink" href="#**Значение,-возвращаемое-оператором-цикла**" title="Permalink"></a></h3><p>В языке Julia любой оператор цикла имеет значение nothing (Nonthing), что обозначает &quot;отсутствие&quot; значения. Это значит, что это значение можно присвоить какой-либо переменной или вернуть из функции (речь, конечно, идет о некоторой формальности).</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Операторы-изменения-поряка-выполнения-цикла**"><a class="docs-heading-anchor" href="#**Операторы-изменения-поряка-выполнения-цикла**"><strong>Операторы изменения поряка выполнения цикла</strong></a><a id="**Операторы-изменения-поряка-выполнения-цикла**-1"></a><a class="docs-heading-anchor-permalink" href="#**Операторы-изменения-поряка-выполнения-цикла**" title="Permalink"></a></h3><p>Иногда бывает необходимо прервать выполнение цикла при выполнении некоторого дополнительного условия - для этого существует оператор <code>break</code>. </p><p>Имеется также оператор <code>continue</code>, который в отличии от break не прерывеат выполнение цикла, а только переключает процесс на следующую итерацию, не дожидаясь выполнения  всех озаписанныз после него действий в теле цикла.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Вложенные-циклы**"><a class="docs-heading-anchor" href="#**Вложенные-циклы**"><strong>Вложенные циклы</strong></a><a id="**Вложенные-циклы**-1"></a><a class="docs-heading-anchor-permalink" href="#**Вложенные-циклы**" title="Permalink"></a></h3><p>Любой цикл может содержать в своем теле другой цикл. Такие циклы называются вложенными.</p><p>При необходимости &quot;выпрыгнуть&quot; за пределы внешнего цикла из какого-либо внутреннего (обычно - при выполнении некоторго условия) следует воспользоваться макросоми @goto и @label. Например,</p><pre><code class="language-julia hljs">for ...
    ...
    for ... 
        ...
        if ...
            @goto label_name
        end
        ...
    end
    ...
end
@label label_name</code></pre><p>С помощью оператора break возможено &quot;выпрыгивание&quot; только за пределы одного текущего цикла. И если пользоваться этим оператором применительно к &quot;выпрыгиванию&quot; за пределы нескольких вложенных циклов, то понадобится целая цепочка таких &quot;выпрыгиваний&quot;, а с помощью @goto - @label это можно будет сделать за одно действие.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Ветвления"><a class="docs-heading-anchor" href="#Ветвления">Ветвления</a><a id="Ветвления-1"></a><a class="docs-heading-anchor-permalink" href="#Ветвления" title="Permalink"></a></h2><p>Ветвления выглядят в общем случае так</p><pre><code class="language-julia hljs">if условие
    тело
end

if условие
    тело_if
else
    тело_else
end

if условие_1
    тело_1
elseif условие_2
    тело_2
...
elseif условие_N # число провряемых усорвий может быть любым
    тело_N
else # эта секция может и отсутствовать
    тело_else
end</code></pre><h3 id="**Значение,-возвращаемое-оператором-ветвления**"><a class="docs-heading-anchor" href="#**Значение,-возвращаемое-оператором-ветвления**"><strong>Значение, возвращаемое оператором ветвления</strong></a><a id="**Значение,-возвращаемое-оператором-ветвления**-1"></a><a class="docs-heading-anchor-permalink" href="#**Значение,-возвращаемое-оператором-ветвления**" title="Permalink"></a></h3><p>В языке Julia начением оператора ветвления является значение последнего оператора в теле выполняемого блока. Например, если</p><pre><code class="language-julia hljs">a=if 2&gt;0
    10
else
    -10
end</code></pre><p>то в результате переменная a получит значение 10.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Переменные,-типы,-выражения"><a class="docs-heading-anchor" href="#Переменные,-типы,-выражения">Переменные, типы, выражения</a><a id="Переменные,-типы,-выражения-1"></a><a class="docs-heading-anchor-permalink" href="#Переменные,-типы,-выражения" title="Permalink"></a></h2><p>Также как и Python язык Julia является языком с динамической типизацией и с выводом типов. Первое означает, что переменная с заданным именем может изменить свой тип в процессе выполнения программы. А второе означает, что типы значений, которыми инициализируются переменные не обязательно явно указывать, компилятор Julia сумеет правильно определить (вывести) тип значения исходя из контекста (например, из способа записи числового значения). </p><p>Например</p><pre><code class="language-julia hljs">x=1   # - тип переменной будет Int64 (или просто - Int)
x=1.0 # - тип переменной (с прежним именем) будет Float64
x=1//2 # - тип переменной будет Ranional{Int64}</code></pre><p>С числовыми значениями можно выполнять обычные арифметические опрерации и применять к ним стандартные математические функции. Пример математического выражения</p><pre><code class="language-julia hljs">1+2*(sin(x)-cos(y))/exp(x+y^3)</code></pre><p>Имеются логические значения <code>true</code>, <code>false</code> (тип <code>Bool</code>), к ним применимы стандартные логические операции <code>&amp;&amp;</code> (&quot;и&quot;), <code>||</code> (&quot;или&quot;), <code>!</code> (&quot;не&quot;) (надо с осторожностью относится к побировым опереациям <code>&amp;</code>, <code>|</code>, <code>~</code>, и неиспользовать их вместо соответствующих логических операций - это может приводить к досадным недороазумениям)</p><p>Операции сравнения: <code>==</code> (&quot;равно&quot;), <code>===</code> (&quot;тождественно равно&quot;), <code>!=</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. Возможны также двойные сравнения <code>1&lt;2&lt;3</code> - даст значение <code>true</code>. </p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Итерируемые-объекты"><a class="docs-heading-anchor" href="#Итерируемые-объекты">Итерируемые объекты</a><a id="Итерируемые-объекты-1"></a><a class="docs-heading-anchor-permalink" href="#Итерируемые-объекты" title="Permalink"></a></h2><p>Итерируемые объекты, это такие объекты, которые могут использоваться в цикле for:</p><pre><code class="language-julia hljs">    for элемент in некоторый_итерируемый_объект
        ...
    end</code></pre><p>Итерируемыми объектами, в частности, являются массивы, диапазоны, генераторы, кортежи, строки, множества, словари.</p><h3 id="**Массивы**"><a class="docs-heading-anchor" href="#**Массивы**"><strong>Массивы</strong></a><a id="**Массивы**-1"></a><a class="docs-heading-anchor-permalink" href="#**Массивы**" title="Permalink"></a></h3><p>Индексация в массивах в языке Julia начинается с 1, так как это принято в математике (в отличие от языка Python, где индексация начинается с 0). Индексы записываются в квадратных скобках. Массивы в Julia являются динамическими, т.е. в процессе выполнения программы в них можно добавлять новые элементы, или удалять из них элементы (но к этой возможности надо относиться с осторожностью, т.к. это может явится причиной существенного замедления выполнения программы).   </p><p>Например,</p><pre><code class="language-julia hljs">a=[10,20,30,40] # - это 1-мерный массив (вектор-столбец)

a[1] - это 10
a[end] - это 40

length(a) - длина массива, равна 4

push!(a,50) - добавляет в конец массива еще один элемент (50)
pop(a) - извлекает из конца массива элемент

a[2]=100 - присваивает новое значение 2-му элементу массива</code></pre><p>Здесь переменная <code>a</code> - это ссылка, т.е. если</p><pre><code class="language-julia hljs">b=a </code></pre><p>то <code>b</code> - это будет ссылка на тот же самый массив, так что изменение значения элемента в <code>b</code> будет означать и изменение в <code>a</code>. Например</p><pre><code class="language-julia hljs">b[2]=0</code></pre><p>даст, что <code>a[2]</code> - это <code>0</code>.</p><p>Чтбы получить копию массива, надо использовать функцию copy. Например,</p><pre><code class="language-julia hljs">с=copy(a)

c[1]=1000</code></pre><p>но <code>a[1]</code> - по-прежнему будет иметь значение 10.</p><p>В Julia существует понятие &quot;среза&quot; массива. Срезы представляют соответствующие части существующего массива. Например, если имееттся массив a длиной 10, то его &quot;срез&quot;, содержащий первую половину, можно получить так:</p><pre><code class="language-julia hljs">b=a[1:5]</code></pre><p>Важно, однако, отметить, что &quot;срезы&quot; в Julia (в отличие, например, от Python) <strong>копируются</strong>. Чтобы получить <strong>ссылку</strong> на &quot;срез&quot; следовало бы сделать так</p><pre><code class="language-julia hljs">b=@view a[1:5]</code></pre><p>Вообще работа с массивами в языке Julia реализована очень удобно и эффективно. В этом отношении (и не только в этом) Julia существенно превосходит язык Python.</p><p>В Julia массивы могут быть самых разных типов. Они также могут быть одномерными, двумерными, многомерными, разряженными, динамическими, статическими. В принципе, и индексация возможна не только с 1, но и с любого другого произвольно заданного значения, включая 0 (но для этого пришлось бы импортировать специальный модуль).</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Диапазоны**"><a class="docs-heading-anchor" href="#**Диапазоны**"><strong>Диапазоны</strong></a><a id="**Диапазоны**-1"></a><a class="docs-heading-anchor-permalink" href="#**Диапазоны**" title="Permalink"></a></h3><p>Кроме массивов в языке Julia, как и в Python, есть еще диапазоны, которые более экономично, по сравнению с массивами, представляются в памяти. Но в Julia диапазоны записвываются иначе. </p><p>Например, <code>1:10</code>, или <code>1:2:10</code> (2 - это шаг, он записывается в середине конструкции; по умолчанию шаг равен 1). </p><p>Дапазоны в Julia, в отличие о от Python, являются замкнутыми, т.е., например, число 10 в ходит в <code>1:10</code>, и число 11 входит в <code>1:2:11</code> (но вот число 10 в <code>1:2:10</code>, разумеется, - не входит). </p><p>Кроме того, начальное, конечное значения диапазона и щаг не обязательно целые числа, они могут быть и с плавающей точкой. Если, например,</p><pre><code class="language-julia hljs">a=10:10:100</code></pre><p>то</p><pre><code class="language-julia hljs">a[1] # - это 10
a[2] # - это 20
....
a[end] # - это 100 </code></pre><p>Но присвоить новое значение элементу диапазона нельзя.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**&quot;Списковые-включения&quot;**"><a class="docs-heading-anchor" href="#**&quot;Списковые-включения&quot;**"><strong>&quot;Списковые включения&quot;</strong></a><a id="**&quot;Списковые-включения&quot;**-1"></a><a class="docs-heading-anchor-permalink" href="#**&quot;Списковые-включения&quot;**" title="Permalink"></a></h3><p>Массивы могут создаваться разными способами. Например, можно использовать так называемое списковое включение:</p><pre><code class="language-julia hljs">[i^2 for i in 1:10]</code></pre><p>В данном случае получится массив квадратов первых <code>10</code> натуральных чисел. Эта конструкция вполне аналогична тому, что есть Python.</p><h3 id="**Генераторы**"><a class="docs-heading-anchor" href="#**Генераторы**"><strong>Генераторы</strong></a><a id="**Генераторы**-1"></a><a class="docs-heading-anchor-permalink" href="#**Генераторы**" title="Permalink"></a></h3><p>А вот такая конструкция</p><pre><code class="language-julia hljs">(i^2 for i in 1:10)</code></pre><p>подобна предыдущей, но результатом ее выполнения является так называемый генератор (последовательности), а не массив. </p><p>Отличие в том, что все члены последовательности сразу не размещаются в памяти, а генерируются по мере надобности по очереди. </p><p>Например, такая конструкция могла бы съэкономить расход памяти в следующем цикле</p><pre><code class="language-julia hljs">for k in (i^2 for i in 1:1_000_000) ... end</code></pre><p>Использовать индексы, для обращения к отдельному элементу генерируемой последовательности нельзя.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Кортежи**"><a class="docs-heading-anchor" href="#**Кортежи**"><strong>Кортежи</strong></a><a id="**Кортежи**-1"></a><a class="docs-heading-anchor-permalink" href="#**Кортежи**" title="Permalink"></a></h3><p>Генераторы не нужно путать с кортежами (Tuple), которые внешне выглядят похоже:</p><pre><code class="language-julia hljs">(1,2,3,4) # - это кортеж</code></pre><p>Это кортеж - в отличие от массивов кортежи не изменяемы, т.е. изменить значение отдельного элемента кортежа нельзя. </p><p>Например,</p><pre><code class="language-julia hljs">a=(10,20,30,40) # - это кортеж
a[1]     # - это равно 10
a[1]=100 # - ошибка: кортеж изменить нельзя</code></pre><p>Кортежи могут использоваться в операторе присваивания, например:</p><pre><code class="language-julia hljs">a,b,c = 1,2,3 # это тоже самое, что и (a,b,c) = (1,2,3)</code></pre><p>в результате получится, что <code>a=1, b=2, c=3</code>.</p><p>Картеж из одного элемента записвывается с помощью запятой в конце, например <code>(2,)</code> - это кортеж, а <code>(2)</code> - это просто <code>2</code>.</p><p>Кортежи могут содержать элементы разных типов. Существуют также <strong>именованные</strong> кортежи (`NanedTuple).</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Строки**"><a class="docs-heading-anchor" href="#**Строки**"><strong>Строки</strong></a><a id="**Строки**-1"></a><a class="docs-heading-anchor-permalink" href="#**Строки**" title="Permalink"></a></h3><p>Строки (<code>String</code>) - это, как и кортежи,  неизменяемые объекты. Например:</p><pre><code class="language-julia hljs">s=&quot;abcdefgh&quot;
s[1] # - это есть символ ASCII &#39;a&#39; (не строка)
s[1]=&#39;b&#39; # - ошибка: изменить строку не возможно</code></pre><p>Со строками возможны операции:</p><pre><code class="language-julia hljs">&quot;absd&quot;*&quot;efgh&quot; # - операция конкатенации (в Python аналогичная операция записывается с помощью символа &quot;+&quot;)

&quot;abc&quot;^3 # - операция дублирования, в данном случае - 3х кратного (в Python аналогичная операция записывается с помощью - &quot;*&quot;)
   
n=3 
println(&quot;number = $(n)&quot;) # - вставляет в строку на место переменной n ее значение (это называется &quot;интерпляцией строк&quot;) 

number = 3</code></pre><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Множества-и-словари**"><a class="docs-heading-anchor" href="#**Множества-и-словари**"><strong>Множества и словари</strong></a><a id="**Множества-и-словари**-1"></a><a class="docs-heading-anchor-permalink" href="#**Множества-и-словари**" title="Permalink"></a></h3><p>В языке Julia (как и в Python) помимо массивов существуют также такие стандартные контейнеры, как множества (<code>Set</code>) и словари (<code>Dict</code>).</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Функция-collect**"><a class="docs-heading-anchor" href="#**Функция-collect**"><strong>Функция collect</strong></a><a id="**Функция-collect**-1"></a><a class="docs-heading-anchor-permalink" href="#**Функция-collect**" title="Permalink"></a></h3><p>Любой итерируемый объект можно превратить в обычный одномерный массив с помощью функции сcollect:</p><pre><code class="language-julia hljs">массив = collect(некоторый_итерируемый_объект)</code></pre><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h3 id="**Операция-&quot;распаковки&quot;-массива**"><a class="docs-heading-anchor" href="#**Операция-&quot;распаковки&quot;-массива**"><strong>Операция &quot;распаковки&quot; массива</strong></a><a id="**Операция-&quot;распаковки&quot;-массива**-1"></a><a class="docs-heading-anchor-permalink" href="#**Операция-&quot;распаковки&quot;-массива**" title="Permalink"></a></h3><p>Если имеется какая-либо <code>n</code>-местная функция <code>f</code> (c n позиционными параметрами), и имеется некоторый массив <code>x</code> из <code>n</code> элементов, то передать элементы этого массива в функцию как отдельные параметры можно так <code>f(x...)</code>.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Система-встроенных-и-пользовательских-типов"><a class="docs-heading-anchor" href="#Система-встроенных-и-пользовательских-типов">Система встроенных и пользовательских типов</a><a id="Система-встроенных-и-пользовательских-типов-1"></a><a class="docs-heading-anchor-permalink" href="#Система-встроенных-и-пользовательских-типов" title="Permalink"></a></h2><p>Помимо многочисленных встроенных типов, среди которых есть как абстрактные, так и конкретные типы, и которые образуют некоторую древовидную иерархическую структуру, в языке Julia возможно создание (встраивание в указанное иерархическое дерево) пользовательских типов данных. Во главе иерархии типов стоит абстрактный тип Any. На концах древовидной структуры, и только на них, находятся все конкретные типы.</p><p>Пользовательские типы данных также могут быть как абстрыктными, так и конкретными. Абстрактные типы не содержат данных, они предназначены только для того, чтобы быть родительскими типами для для каких-либо других типов, абстрактных или конкретных.</p><p>Абстрактные типы определяются с помощью специальной синтаксической конструкции abstract type-end, и не содержат ничего, кроме указания имени нового типа и имени его родительского типа.</p><p>Конкретные же типы определяются с помощью конструкции struct-end, подобно тому, как это имеет место в C-подобных языках. Но, конечно, имеются и существенные отличия от этих языков. </p><p>Различные типы могут находиться между собой в отношении предок-потомок. Для выяснения того, какие типы являются дочерними, а какой - родительским, для какого-либо заданного типа имеются специальные встроенные функции <code>subtypes</code>, <code>supertype</code>, соответственно. </p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Вывод-на-экран"><a class="docs-heading-anchor" href="#Вывод-на-экран">Вывод на экран</a><a id="Вывод-на-экран-1"></a><a class="docs-heading-anchor-permalink" href="#Вывод-на-экран" title="Permalink"></a></h2><p>Для вывода значений на экран имеются функции print, println. Например,</p><pre><code class="language-julia hljs">println(выражение_1, выражение_2,...,выражение_N)</code></pre><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Работа-в-REPL"><a class="docs-heading-anchor" href="#Работа-в-REPL">Работа в REPL</a><a id="Работа-в-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Работа-в-REPL" title="Permalink"></a></h2><p>При работе в REPL иногда возникает необходимость отменить ранее сделанные определения. Напимер, если была создана переменная <code>x</code>:</p><pre><code class="language-julia hljs">julia&gt; x=10000</code></pre><p>то удалить её саму из области памяти REPL окажется невозможным. То есть, невозможно именно удалить имя, а не изменить значение. Можно лишь присвоить этой переменной значение <code>nothing</code> (тип этого значения — <code>Nothing</code>), что будет означать «отсутствие» значения.</p><pre><code class="language-julia hljs">julia&gt; x=nothing</code></pre><p>(значение-то на самом деле есть, просто оно — <code>nothing</code>, поэтому и поставлены кавычки).</p><p>Если была определена функция, например,</p><pre><code class="language-julia hljs">julia&gt; f(x::Int)=x^2</code></pre><p>то удалить её из области REPL тоже не получится. Но её можно будет переопределить, сохранив типы аргументов, например:</p><pre><code class="language-julia hljs">julia&gt; f(x::Int)=x^3</code></pre><p>Но вот если изменить при этом тип аргумента, например:</p><pre><code class="language-julia hljs">julia&gt; f(x::Float64)=x^2</code></pre><p>то окажется, что старое определение не исчезнет, а будет одновременно существовать два метода одной обобщённой (<code>generic</code>) функции (см. выше о множественной диспетчеризации).</p><p>В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции <code>exit</code>:</p><pre><code class="language-julia hljs">julia&gt; exit()</code></pre><p>В среде VS Code можно, однако, открыть ещё и новый экземпляр REPL, и продолжить работу в нём, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Немного-о-терминологии"><a class="docs-heading-anchor" href="#Немного-о-терминологии">Немного о терминологии</a><a id="Немного-о-терминологии-1"></a><a class="docs-heading-anchor-permalink" href="#Немного-о-терминологии" title="Permalink"></a></h2><p>В классических объектно-ориентированных языках программирования говорят о <em>классах</em>, имеющих <em>методы</em>. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия «метод» используется понятие «функция-член класса», а ещё там есть функции, «дружественные» классу.</p><p>В таких языках <em>класс</em> — это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.</p><p>А вот в языке Julia вместо классов есть типы. У типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод <em>специализирует</em> обобщённую (<code>generic</code>) функцию.</p><p>Обычно также в объектно-ориентированных языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении <code>Nord</code> в языке Python могла бы выглядеть так: <code>r.move(Nord)</code>. Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты какого-либо типа могут являться лишь обычными аргументами своей функци</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Интроспекция"><a class="docs-heading-anchor" href="#Интроспекция">Интроспекция</a><a id="Интроспекция-1"></a><a class="docs-heading-anchor-permalink" href="#Интроспекция" title="Permalink"></a></h2><p>Для выяснения того, какого типа то или иное значение, имеется встроенная функция typeof. Также в REPL имеется удобная встроенная система помощи, с помощью которой можно получить много полезной информации о типах данных и функциях языка Julia.</p><hr/><p><a href="#ОГЛАВЛЕНИЕ">(&lt;&lt; К ОГЛАВЛЕНИЮ)</a></p><h2 id="Дополнительные-источники-информации-о-языке-Julia"><a class="docs-heading-anchor" href="#Дополнительные-источники-информации-о-языке-Julia">Дополнительные источники информации о языке Julia</a><a id="Дополнительные-источники-информации-о-языке-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Дополнительные-источники-информации-о-языке-Julia" title="Permalink"></a></h2><p>Более подробные сведения о языке Julia можно почерпнуть, например, </p><p><a href="https://techytok.com/from-zero-to-julia/">здесь</a>, а также <a href="http://www.lib.unn.ru/students/src/JULIA_tutorial.pdf">здесь</a>, или <a href="https://biologo.ru/korotko-o-yazike-programmirovaniya/index8.pdf">здесь</a>. Однако информация о некоторых функциях, содержащаяся в двух последних источниках, может оказаться устаревшей, т.к. она относится к еще не стабильным версиям языка (до 1.0).</p><p>Для более полного ознакомления с языком следует обращаться к <a href="https://docs.julialang.org/en/v1/">официальной документации</a>.</p><p>Дополнительные ссылки на полезные источники информации о языке Julia собраны <a href="../links/">здесь</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Пример выполнения программы для Робота</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 29 May 2023 13:09">Monday 29 May 2023</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
