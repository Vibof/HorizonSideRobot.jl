# НАЧАЛЬНЫЕ СВЕДЕНИЯ О ЯЗЫКЕ ПРОГРАММИРОВАНИЯ JULIA

Если вы знакомы с языком Python, то очень многое в языке Julia вам покажется знакомым. Но есть и существенные различия. 

Например, в языке Julia отступы не имеют принципиального значения, такое как они имеют в языке Python, где отступы определяют структуру кода. И не надо ставить двоеточия в конце заголовков функций, циклов и т.д., как в Python. Вместо всего этого используется ключевое слово `end`, ограничивающее тело той или иной конструкции языка (см. ниже).

Но тем не менее язык Julia во многом похож Python (но это только внешнее сходство). Благодаря этому сходству, например, часто удаётся выяснить имя и описание какой-либо вдруг понадобившейся стандартной функции Julia (если по каким-то причинам это не удалось сделать напрямую): велика вероятность того, что нужная функция называется и действует так же, как и в Python. При этом на сегодняшнй день информацию по языку Python на русском языке найти значительно проще.

----------------

## ОГЛАВЛЕНИЕ

- [НАЧАЛЬНЫЕ СВЕДЕНИЯ О ЯЗЫКЕ ПРОГРАММИРОВАНИЯ JULIA](@ref)
  - [Функции](@ref)
    - [**Способы определения функций**](@ref)
    - [**Позиционные параметры функций**](@ref)
    - [**Формальные и фактические параметры функций**](@ref)
    - [**Позиционные и именованные параметры**](@ref)
    - [**Возвращаемые функцией значения**](@ref)
    - [**Множественная диспетчеризация**](@ref)
  - [Циклы](@ref)
    - [**"Арифметический" цикл**](@ref)
    - [**Цикл с предусловием**](@ref)
    - [**Значение, возвращаемое оператором цикла**](@ref)
    - [**Операторы изменения поряка выполнения цикла**](@ref)
    - [**Вложенные циклы**](@ref)
  - [Ветвления](@ref)
    - [**Значение, возвращаемое оператором ветвления**](@ref)
  - [Переменные, типы, выражения](@ref)
  - [Итерируемые объекты](@ref)
    - [**Массивы**](@ref)
    - [**Диапазоны**](@ref)
    - [**"Списковые включения"**](@ref)
    - [**Генераторы**](@ref)
    - [**Кортежи**](@ref)
    - [**Строки**](@ref)
    - [**Множества и словари**](@ref)
    - [**Функция collect**](@ref)
    - [**Операция "распаковки" массива**](@ref)
  - [Система встроенных и пользовательских типов](@ref)
  - [Вывод на экран](@ref)
  - [Работа в REPL](@ref)
  - [Немного о терминологии](@ref)
  - [Интроспекция](@ref)
  - [Дополнительные источники информации о языке Julia](@ref)
 
-------------------------------------------------------------------------------------

## Функции

Функции - это основные "кирпичики" из которых состоят программы. 

Сама программа, обычно, тоже является функцией, которую называют главной функцией.

### **Способы определения функций**
Например, определение некоторой функции с одним агрументом (параметром) может выглядеть так
```julia
function f(x)
    return x^2
end
```
или так
```julia
function f(x)
    x^2 # функция всегда возвращает значение последнего оператора в своем теле
end
```
или даже так
```julia
f(x)=x^2
```
Последний способ обычно используют для совсем коротких определений.

-------------------------------------
[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Позиционные параметры функций**
Количество аргументов у функций может быть любым, в том числе параметров может не быть совсем.

Вот пример функции без параметров

```julia
one()=1
```

А вот пример функции с двумя параметрами
```julia
expr(x,y)=sin(x)+cos(y)
```
В приведенном примере параметры функции называются **позиционными**. Смысл этого названия разъясняется в следующем подразделе.

-------------------------------------
[(<< К ОГЛАВЛЕНИЮ)](#начальные-сведения-о-языке-программирования-julia)

### **Формальные и фактические параметры функций**

Параметры, которые фигурируют в **определениях** функций принято называть **формальными**. По сути формальные параметры представляют собой просто символы, которые требуются, чтобы записать алгоритм вычисления функции. Имя любого формального параметра может быть заменено на другое, и от этого опредление функции не изменится.

А вот при вызове функции на исполнение, на место формальных параметров должны быть подставлены **фактические** параметры, которые должны представлять некоторые конкретные значения.

В рассмотренных примерах все аргументы функций являлись так называемыми **позиционными параметрами**. Это название происходит от того, что соответствие между формальными и фактическими параметрами устанавливается благодаря тому, что в списке параметров их позици фиксированы, т.е. каждому параметру определено строго определенное место в списке.

-------------------------------------
[(<< К ОГЛАВЛЕНИЮ)](#начальные-сведения-о-языке-программирования-julia)

### **Позиционные и именованные параметры**

В языке Julia (как и в языке Python) наряду с позиционными параметрами у функций могут быть также и **именованные параметры** или их еще называют **ключевыми (key) параметрами**. 
Так называются параметры, за которыми прочно закреплены их имена. Например, известная нам функция `Robot` имеет именованный параметр `animate`. При вызове данной функции на исполнение этот параметр используется так
```julia
Robot(animate=true)
```

Функция может иметь как позиционные, так и именованные параметры, одновременно.  Такова, например, все таже функция `Robot`, у которой возможны два позиционных и один именованный параметры
```julia
Robot(10, 15, animate=true)
```
В определении функций с обоими типами параметров в списке параметров сначала должны перечисляться все позиционные параметры, а затем, после ";" - все именованные (которых тоже может быть несколько).
При вызове же этих функций на исполнение, после позиционных именованные параметры могут располагаться в произвольном порядке (позиционные от именованных - могут разделяться просто ",", но допустима также и ";").

Как именованные, так и позиционные параметры могут иметь **значения по умолчанию**. Например, 
```julia
julia> quadratic(x,a=1,b=0,c=0)=a*x^2+b*x+c

julia> quadratic(2)
    4
```
(здесь все параметры у функции - позиционные).

Стоит отметить, что в отношении использования именованных параметров синтаксис языка Julia отличается от синтаксиса Python.

-------------------------------------
[(<< К ОГЛАВЛЕНИЮ)](#начальные-сведения-о-языке-программирования-julia)

### **Возвращаемые функцией значения**

Если результатом выполнения функции является некоторое значение, то, как правило, функция должна это значение ВОЗВРАЩАТЬ. Для этого в теле функции может быть использован специальный оператор возврата - `return`. Этот оператор немедленно завершает выполнение функции и передает управление во вне, в точку ее вызова. В ту же точку возвращается (подставляется) возвращаемое функцией значение.

Если функция что-либо возвращает, то ее вызов может осуществляться из некоторого выражения, например из правой части оператора присваивания. 

Если функция ничего не возвращает, а просто выполняет какие-то другие действия, то такиая функция, в некоторых языках программирования называется **процедурой**. Но в языке Julia такая терминология не используется. В языке Julia любая функция что-то возвращает, даже если она ничего возвращать не должна. В последнем случае возвращаемое значение будет `nothing`.

Выше рассматривались примеры функций, возвращающих ровно одно значение.

Если требуется, чтобы функция возвращала несколько значений, то эти возвращаемые значения должны составляться в кортеж (подробнее о кортежах см. ниже), например
```julia
fun(x,y)=(x+y, x-y) # (x+y, x-y) - это кортеж из двух значений
```
Если при этом используется оператор return, то скобки ставить не обязательно:
```julia
function fun(x,y)
    return x+y, x-y
end
```

В любом случае в результате вызова 
```julia
a,b=fun(3,2)
```
получится `a=5`, `b=1`.

-------------------------------------
[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Множественная диспетчеризация**

Важная отличительная особенность языка Julia от языка Python, заключается в том, что в определениях функций типы их аргументов можно анотировать, т.е. указывать, какими они должны быть.

Например, можно было бы дать еще следующие 2 определения
```julia
function f(x::Int)
    return x^3
end

function f(x::Float64)
    return x^4
end
```

В результате мы получим еще два метода (варианта) функции f. Оба пределения функции f одновременно быдут существовать. Какое из них будет использовано - зависит от фактического типа аргумента функции (т.е. с аргументом какого типа будет ее вызов). Это называется [множественной диспетчеризацией](https://techytok.com/lesson-multiple-dispatch/). 

Зачем нужна множественная диспетчеризация, и как ей правильно пользоваться в языке Julia - это предмет отдельного разговора. Но заранее заметим, что эта тема имеет в Julia первостепеное значение. 

-------------------------------------
[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Циклы

### **"Арифметический" цикл**
```julia   
for a in collection 
    println(a)
end

где collecnion - это может быть диапазон, массив (Array), генератор, строка (String), множество (Set), словать (Dict) - см. ниже. 

Например collection = [10,20,30,40,50] - это массив (в данном случае - вектор-столбец)

for i in eachindex(collection) # перебираются индексы элементов колллеции
    println(i)
end

for (i,a) in enumerate(collection) # перебираются пары индекс-значение элементов колллеции
    println(i," -> ", a) 
end
```

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Цикл с предусловием**
```Julia

while условие_продолжения_цикла
    ...
end
```
### **Значение, возвращаемое оператором цикла**

В языке Julia любой оператор цикла имеет значение nothing (Nonthing), что обозначает "отсутствие" значения. Это значит, что это значение можно присвоить какой-либо переменной или вернуть из функции (речь, конечно, идет о некоторой формальности).


------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Операторы изменения поряка выполнения цикла**

Иногда бывает необходимо прервать выполнение цикла при выполнении некоторого дополнительного условия - для этого существует оператор `break`. 

Имеется также оператор `continue`, который в отличии от break не прерывеат выполнение цикла, а только переключает процесс на следующую итерацию, не дожидаясь выполнения  всех озаписанныз после него действий в теле цикла.

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Вложенные циклы**

Любой цикл может содержать в своем теле другой цикл. Такие циклы называются вложенными.

При необходимости "выпрыгнуть" за пределы внешнего цикла из какого-либо внутреннего (обычно - при выполнении некоторго условия) следует воспользоваться макросоми @goto и @label. Например,
```julia
for ...
    ...
    for ... 
        ...
        if ...
            @goto label_name
        end
        ...
    end
    ...
end
@label label_name
```
С помощью оператора break возможено "выпрыгивание" только за пределы одного текущего цикла. И если пользоваться этим оператором применительно к "выпрыгиванию" за пределы нескольких вложенных циклов, то понадобится целая цепочка таких "выпрыгиваний", а с помощью @goto - @label это можно будет сделать за одно действие.

--------------------------------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Ветвления

Ветвления выглядят в общем случае так
```julia
if условие
    тело
end

if условие
    тело_if
else
    тело_else
end

if условие_1
    тело_1
elseif условие_2
    тело_2
...
elseif условие_N # число провряемых усорвий может быть любым
    тело_N
else # эта секция может и отсутствовать
    тело_else
end
```
### **Значение, возвращаемое оператором ветвления**

В языке Julia начением оператора ветвления является значение последнего оператора в теле выполняемого блока.
Например, если
```julia
a=if 2>0
    10
else
    -10
end
```
то в результате переменная a получит значение 10.

------------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Переменные, типы, выражения

Также как и Python язык Julia является языком с динамической типизацией и с выводом типов. Первое означает, что переменная с заданным именем может изменить свой тип в процессе выполнения программы. А второе означает, что типы значений, которыми инициализируются переменные не обязательно явно указывать, компилятор Julia сумеет правильно определить (вывести) тип значения исходя из контекста (например, из способа записи числового значения). 

Например
```julia
x=1   # - тип переменной будет Int64 (или просто - Int)
x=1.0 # - тип переменной (с прежним именем) будет Float64
x=1//2 # - тип переменной будет Ranional{Int64}
```
С числовыми значениями можно выполнять обычные арифметические опрерации и применять к ним стандартные математические функции. Пример математического выражения
```julia
1+2*(sin(x)-cos(y))/exp(x+y^3)
```
Имеются логические значения `true`, `false` (тип `Bool`), к ним применимы стандартные логические операции `&&` ("и"), `||` ("или"), `!` ("не")
(надо с осторожностью относится к побировым опереациям `&`, `|`, `~`, и неиспользовать их вместо соответствующих логических операций - это может приводить к досадным недороазумениям)

Операции сравнения: `==` ("равно"), `===` ("тождественно равно"), `!=`, `!==`, `<`, `>`, `<=`, `>=`.
Возможны также двойные сравнения `1<2<3` - даст значение `true`. 

-----------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Итерируемые объекты 
Итерируемые объекты, это такие объекты, которые могут использоваться в цикле for:
```julia
    for элемент in некоторый_итерируемый_объект
        ...
    end
```
Итерируемыми объектами, в частности, являются массивы, диапазоны, генераторы, кортежи, строки, множества, словари.

### **Массивы**

Индексация в массивах в языке Julia начинается с 1, так как это принято в математике (в отличие от языка Python, где индексация начинается с 0). Индексы записываются в квадратных скобках. Массивы в Julia являются динамическими, т.е. в процессе выполнения программы в них можно добавлять новые элементы, или удалять из них элементы (но к этой возможности надо относиться с осторожностью, т.к. это может явится причиной существенного замедления выполнения программы).   

Например,
```julia
a=[10,20,30,40] # - это 1-мерный массив (вектор-столбец)

a[1] - это 10
a[end] - это 40

length(a) - длина массива, равна 4

push!(a,50) - добавляет в конец массива еще один элемент (50)
pop(a) - извлекает из конца массива элемент

a[2]=100 - присваивает новое значение 2-му элементу массива
```    
Здесь переменная `a` - это ссылка, т.е. если
```julia
b=a 
```
то `b` - это будет ссылка на тот же самый массив, так что
изменение значения элемента в `b` будет означать и изменение в `a`. Например
```julia
b[2]=0
```
даст, что `a[2]` - это `0`.

Чтбы получить копию массива, надо использовать функцию copy. Например,
```julia
с=copy(a)

c[1]=1000
```
но `a[1]` - по-прежнему будет иметь значение 10.

В Julia существует понятие "среза" массива. Срезы представляют соответствующие части существующего массива. Например, если имееттся массив a длиной 10, то его "срез", содержащий первую половину, можно получить так:
```julia
b=a[1:5]
```
Важно, однако, отметить, что "срезы" в Julia (в отличие, например, от Python) **копируются**. Чтобы получить **ссылку** на "срез" следовало бы сделать так
```julia
b=@view a[1:5]
```
Вообще работа с массивами в языке Julia реализована очень удобно и эффективно. В этом отношении (и не только в этом) Julia существенно превосходит язык Python.

В Julia массивы могут быть самых разных типов. Они также могут быть одномерными, двумерными, многомерными, разряженными, динамическими, статическими. В принципе, и индексация возможна не только с 1, но и с любого другого произвольно заданного значения, включая 0 (но для этого пришлось бы импортировать специальный модуль).

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Диапазоны**

Кроме массивов в языке Julia, как и в Python, есть еще диапазоны, которые более экономично, по сравнению с массивами, представляются в памяти. Но в Julia диапазоны записвываются иначе. 

Например, `1:10`, или `1:2:10` (2 - это шаг, он записывается в середине конструкции; по умолчанию шаг равен 1). 

Дапазоны в Julia, в отличие о от Python, являются замкнутыми, т.е., например, число 10 в ходит в `1:10`, и число 11 входит в `1:2:11` (но вот число 10 в `1:2:10`, разумеется, - не входит). 

Кроме того, начальное, конечное значения диапазона и щаг не обязательно целые числа, они могут быть и с плавающей точкой.
Если, например,
```julia
a=10:10:100
```
то
```julia
a[1] # - это 10
a[2] # - это 20
....
a[end] # - это 100 
```
Но присвоить новое значение элементу диапазона нельзя.

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **"Списковые включения"**

Массивы могут создаваться разными способами. Например, можно использовать так называемое списковое включение:
```julia    
[i^2 for i in 1:10]
```
В данном случае получится массив квадратов первых `10` натуральных чисел. Эта конструкция вполне аналогична тому, что есть Python.

### **Генераторы**

А вот такая конструкция
```julia    
(i^2 for i in 1:10)
```
подобна предыдущей, но результатом ее выполнения является так называемый генератор (последовательности), а не массив. 

Отличие в том, что все члены последовательности сразу не размещаются в памяти, а генерируются по мере надобности по очереди. 

Например, такая конструкция могла бы съэкономить расход памяти в следующем цикле
```julia
for k in (i^2 for i in 1:1_000_000) ... end
```
Использовать индексы, для обращения к отдельному элементу генерируемой последовательности нельзя.

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Кортежи**

Генераторы не нужно путать с кортежами (Tuple), которые внешне выглядят похоже:
```julia
(1,2,3,4) # - это кортеж
```
Это кортеж - в отличие от массивов кортежи не изменяемы, т.е. изменить значение отдельного элемента кортежа нельзя. 

Например,
```julia
a=(10,20,30,40) # - это кортеж
a[1]     # - это равно 10
a[1]=100 # - ошибка: кортеж изменить нельзя
```
Кортежи могут использоваться в операторе присваивания, например:
```julia
a,b,c = 1,2,3 # это тоже самое, что и (a,b,c) = (1,2,3)
```
в результате получится, что `a=1, b=2, c=3`.

Картеж из одного элемента записвывается с помощью запятой в конце, например `(2,)` - это кортеж, а `(2)` - это просто `2`.

Кортежи могут содержать элементы разных типов. Существуют также **именованные** кортежи (`NanedTuple).

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Строки**

Строки (`String`) - это, как и кортежи,  неизменяемые объекты. Например:
```julia
s="abcdefgh"
s[1] # - это есть символ ASCII 'a' (не строка)
s[1]='b' # - ошибка: изменить строку не возможно
```
Со строками возможны операции:
```julia
"absd"*"efgh" # - операция конкатенации (в Python аналогичная операция записывается с помощью символа "+")

"abc"^3 # - операция дублирования, в данном случае - 3х кратного (в Python аналогичная операция записывается с помощью - "*")
   
n=3 
println("number = $(n)") # - вставляет в строку на место переменной n ее значение (это называется "интерпляцией строк") 

number = 3
```   

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Множества и словари**

В языке Julia (как и в Python) помимо массивов существуют также такие стандартные контейнеры, как множества (`Set`) и словари (`Dict`).

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Функция collect**

Любой итерируемый объект можно превратить в обычный одномерный массив с помощью функции сcollect:
```julia
массив = collect(некоторый_итерируемый_объект)
```

------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

### **Операция "распаковки" массива**

Если имеется какая-либо `n`-местная функция `f` (c n позиционными параметрами), и имеется некоторый массив `x` из `n` элементов, то передать элементы этого массива в функцию как отдельные параметры можно
так `f(x...)`.

---------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)


## Система встроенных и пользовательских типов

Помимо многочисленных встроенных типов, среди которых есть как абстрактные, так и конкретные типы, и которые образуют некоторую древовидную иерархическую структуру, в языке Julia возможно создание (встраивание в указанное иерархическое дерево) пользовательских типов данных. Во главе иерархии типов стоит абстрактный тип Any. На концах древовидной структуры, и только на них, находятся все конкретные типы.

Пользовательские типы данных также могут быть как абстрыктными, так и конкретными. Абстрактные типы не содержат данных, они предназначены только для того, чтобы быть родительскими типами для для каких-либо других типов, абстрактных или конкретных.

Абстрактные типы определяются с помощью специальной синтаксической конструкции abstract type-end, и не содержат ничего, кроме указания имени нового типа и имени его родительского типа.

Конкретные же типы определяются с помощью конструкции struct-end, подобно тому, как это имеет место в C-подобных языках. Но, конечно, имеются и существенные отличия от этих языков. 

Различные типы могут находиться между собой в отношении предок-потомок. Для выяснения того, какие типы являются дочерними, а какой - родительским, для какого-либо заданного типа имеются специальные встроенные функции `subtypes`, `supertype`, соответственно. 

----------------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Вывод на экран

Для вывода значений на экран имеются функции print, println. Например,
```julia
println(выражение_1, выражение_2,...,выражение_N)
```

--------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Работа в REPL

При работе в REPL иногда возникает необходимость отменить ранее сделанные определения. Напимер, если была создана переменная `x`:
```julia
julia> x=10000
```
то удалить её саму из области памяти REPL окажется невозможным. То есть, невозможно именно удалить имя, а не изменить значение. Можно лишь присвоить этой переменной значение `nothing` (тип этого значения — `Nothing`), что будет означать «отсутствие» значения.
```julia
julia> x=nothing
```
(значение-то на самом деле есть, просто оно — `nothing`, поэтому и поставлены кавычки).

Если была определена функция, например,
```julia
julia> f(x::Int)=x^2
```
то удалить её из области REPL тоже не получится. Но её можно будет переопределить, сохранив типы аргументов, например:
```julia
julia> f(x::Int)=x^3
```
Но вот если изменить при этом тип аргумента, например:
```julia
julia> f(x::Float64)=x^2
```
то окажется, что старое определение не исчезнет, а будет одновременно существовать два метода одной обобщённой (`generic`) функции (см. выше о множественной диспетчеризации).

В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции `exit`:
```julia    
julia> exit()
```
В среде VS Code можно, однако, открыть ещё и новый экземпляр REPL, и продолжить работу в нём, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).

------------------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Немного о терминологии

В классических объектно-ориентированных языках программирования говорят о *классах*, имеющих *методы*. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия «метод» используется понятие «функция-член класса», а ещё там есть функции, «дружественные» классу.

В таких языках *класс* — это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.

А вот в языке Julia вместо классов есть типы. У типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод *специализирует* обобщённую (`generic`) функцию.

Обычно также в объектно-ориентированных языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении `Nord` в языке Python могла бы выглядеть так: `r.move(Nord)`. Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты какого-либо типа могут являться лишь обычными аргументами своей функци

---------------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Интроспекция

Для выяснения того, какого типа то или иное значение, имеется встроенная функция typeof.
Также в REPL имеется удобная встроенная система помощи, с помощью которой можно получить много полезной информации о типах данных и функциях языка Julia.

----------------------------------------

[(<< К ОГЛАВЛЕНИЮ)](#ОГЛАВЛЕНИЕ)

## Дополнительные источники информации о языке Julia

Более подробные сведения о языке Julia можно почерпнуть, например, 

[здесь](https://techytok.com/from-zero-to-julia/), а также [здесь](http://www.lib.unn.ru/students/src/JULIA_tutorial.pdf), или [здесь](https://biologo.ru/korotko-o-yazike-programmirovaniya/index8.pdf).
Однако информация о некоторых функциях, содержащаяся в двух последних источниках, может оказаться устаревшей, т.к. она относится к еще не стабильным версиям языка (до 1.0).

Для более полного ознакомления с языком следует обращаться к [официальной документации](https://docs.julialang.org/en/v1/).

Дополнительные ссылки на полезные источники информации о языке Julia собраны [здесь](links.md).
